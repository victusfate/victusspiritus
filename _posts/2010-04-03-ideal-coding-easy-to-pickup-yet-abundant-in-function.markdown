---
layout: post
status: publish
published: true
title: 'Ideal Coding: Easy to Pickup Yet Abundant in Function'
author: Mark Essel
author_login: messel
author_email: messel@gmail.com
author_url: http://messel.myopenid.com/
wordpress_id: 3438
wordpress_url: http://www.victusspiritus.com/?p=3438
date: '2010-04-03 05:50:05 -0400'
date_gmt: '2010-04-03 12:50:05 -0400'
categories:
- Uncategorized
tags:
- web/tech
- collaboration
- software
- coding
- design
comments:
- id: 3746
  author: gtani
  author_email: gene.tani@gmail.com
  author_url: ''
  date: '2010-04-04 06:05:30 -0400'
  date_gmt: '2010-04-04 11:05:30 -0400'
  content: Have you looked at clojure, erlang and F#?  These are compact ("low ceremony")
    functional languages, with concurrency/async processing capabilities.  Also, if
    you spend a bit of time with them first, scala and haskell don&#39;t look so unattainable.<br><br>One
    thing, I don&#39;t think clojure and scala qualify as "save-and-run" scripting
    languages (python and ruby-style), between JVM startup time and having to mess
    with classpaths
- id: 3750
  author: Mark Essel
  author_email: messel@gmail.com
  author_url: http://www.victusspiritus.com/
  date: '2010-04-04 10:12:42 -0400'
  date_gmt: '2010-04-04 15:12:42 -0400'
  content: I&#39;ve not yet looked them over. There seem to be many languages that
    appeared over the past 15 years that just slipped past me. Now playing catchup
    is truly an exploration. The social popularity (libraries + open source) is another
    factor. Which out of your suggestions do you feel is the fastest growing (ease
    of entry/use is probably a big part of that).<br><br>I liked my browsing /toying
    first look at scala (I have Dave Pollack&#39;s book). It was troublesome getting
    a good netbeans IDE on my windows desktop last year. Maybe it&#39;s simpler on
    Ubuntu. I&#39;m interested in seeing how far a dynamic language can go for my
    needs
- id: 3757
  author: gtani
  author_email: gene.tani@gmail.com
  author_url: ''
  date: '2010-04-04 14:38:18 -0400'
  date_gmt: '2010-04-04 19:38:18 -0400'
  content: 'Hi Mark,<br><br>all 5 FP language I mentioned have learning resources:
    blog tutorials,<br>books, people answering questions on IRC channel (##fsharp,
    not #fsharp) and<br>stackoverflow, Learn You a Haskell/Erlang, etc.<br><br>The
    Pragmatic books on erlang and scala are very gentle introductions to the<br>languages.  The
    Oreilly books on F#, erlang and scala are excellent, maybe<br>more firehosey.
    (The Oreilly books on scala and haskell are available to<br>read online in their
    entirety, too)<br><br><a href="http://book.realworldhaskell.org/" rel="nofollow">http://book.realworldhaskell.org/</a><br><br><a
    href="http://programming-scala.labs.oreilly.com/" rel="nofollow">http://programming-scala.labs.oreilly.com/</a>'
- id: 4078
  author: Instant Utility, Optimal Execution, &amp; Syntactic Sugar &laquo; Victus
    Spiritus
  author_email: ''
  author_url: http://victusfate.github.io/victusspiritus/uncategorized/2010/04/20/instant-utility-optimal-execution-syntactic-sugar/
  date: '2010-04-20 05:43:00 -0400'
  date_gmt: '2010-04-20 12:43:00 -0400'
  content: "[...] few weeks, I awoke at 4am with run time and code style anxiety.
    Some might label this a case of premature optimization, because I&#8217;m worried
    about execution time and readability of code I haven&#8217;t written [...]"
- id: 4403
  author: Global Communication for Free - Victus Spiritus
  author_email: ''
  author_url: http://victusfate.github.io/victusspiritus/uncategorized/2010/05/25/global-communication-for-free/
  date: '2010-05-25 04:57:15 -0400'
  date_gmt: '2010-05-25 11:57:15 -0400'
  content: "[...] I still get fast results by asking questions and getting answers
    from willing sources (or reading Jorg&#8217;s answers on Stack Overflow). I can
    find and reach out to other people who share the simple but big goal of free global
    [...]"
- id: 4514
  author: gucci
  author_email: bgd1396@yahoo.com
  author_url: http://www.gucci-outlet-store.com/
  date: '2010-06-11 06:43:02 -0400'
  date_gmt: '2010-06-11 11:43:02 -0400'
  content: Well , the view of the passage is  totally correct ,your details is really
    reasonable and you guy give us valuable informative post, I totally agree the
    standpoint of upstairs. I often surfing on this forum when I m free and I find
    there are so much good information we can learn in this forum! <a href="http://www.thecrowdisgone.com/"
    rel="nofollow">http://www.thecrowdisgone.com/</a>
- id: 4522
  author: air jordan 9
  author_email: wang20091988@gmail.com
  author_url: http://www.air-jordan-9.com/
  date: '2010-06-11 08:18:02 -0400'
  date_gmt: '2010-06-11 13:18:02 -0400'
  content: Here elaborates the matter not only extensively but also detailly .I support
    the <br>write&#39;s unique point.It is useful and benefit to your daily life.You
    can go those <br>sits to know more relate things.They are strongly recommended
    by friends.Personally!<br><a href="http://www.you-rselfas.com" rel="nofollow">www.you-rselfas.com</a>
- id: 4666
  author: Is there a Moore&#8217;s Law for Machine Intelligence? | Victus Spiritus
  author_email: ''
  author_url: http://victusfate.github.io/victusspiritus/uncategorized/2010/07/03/is-there-a-moores-law-for-machine-intelligence/
  date: '2010-07-03 03:41:38 -0400'
  date_gmt: '2010-07-03 10:41:38 -0400'
  content: "[...] of time) compiling, sharp developers are converging on a balance
    between optimal performance and ease of use along with [...]"
- id: 6232
  author: Exploring speculative execution and evaluation &raquo; Victus Spiritus
  author_email: ''
  author_url: http://victusfate.github.io/victusspiritus/uncategorized/2010/10/02/exploring-speculative-execution-and-evaluation/
  date: '2010-10-02 20:15:26 -0400'
  date_gmt: '2010-10-03 03:15:26 -0400'
  content: "[...] blends compilation and continuous interpretation for maximum efficiency.
    I touched briefly on just in time compiling when predicting changes to programming
    in the coming [...]"
---
<h2><a href="http://www.stuckincustoms.com/2010/03/26/tokyo-from-a-window/"><img class="aligncenter size-full wp-image-3445" title="StuckInCustomsTokyo" src="{{ site.url }}/assets/2010/04/StuckInCustomsTokyo.jpg" alt="" width="600" height="388" /></a></h2>
<h2>Who likes waiting for more complex programs to run?</h2>
<p>In doing some research on fast dynamic programming languages, a couple of great finds caught my attention. I'm seeking a language that feels like <a class="zem_slink" title="Ruby (programming language)" rel="homepage" href="http://www.ruby-lang.org/">Ruby</a> but can run natively faster than using the MRI for the types of problems I like to work on (some numerically intensive). Alternatively, I don't want to waste time with <a class="zem_slink" title="Program optimization" rel="wikipedia" href="http://en.wikipedia.org/wiki/Program_optimization">premature optimization</a>. I am looking for a development language that is easy for me to create in, build on, and fast to execute, and finally has the easy to read syntactical feel of Ruby (I often reread my own code to figure it out months/years later). I've looked at Scala before, but have found much more enjoyment in Ruby coding. My fear is that a faster execution environment will detract from the qualities that endear me to dynamic languages (I come from c++ my day job's default, so all of this is gravy to me). JRuby has shown some promise as well as the underlying tools (Duby) that are used to make interpreting Ruby on the JVM a more enjoyable process.</p>
<h2>Q&amp;A on Stack Overflow</h2>
<p>Fortune smiled on me early this morning. I came across a couple of <a class="zem_slink" title="Stack Overflow" rel="homepage" href="http://stackoverflow.com/">Stack Overflow</a> answers which I appreciated on several levels. Over the past week I've grown accustomed to waking at 4 and searching for topics that have been bothering me. If the meritocracy of dynamic programming (features over class hierarchies) and malleable language structures call to your creative interests, you may need:</p>
<p>a) psychological help ;) or</p>
<p>b) a damn good dynamic programming language</p>
<p>The first question "Are dynamic languages slower than static languages". <a href="http://stackoverflow.com/users/2988/jorg-w-mittag">Jorg W Mittag's</a> well crafted <a href="http://stackoverflow.com/questions/2198684/are-dynamic-languages-slower-than-static-languages/2200486#2200486">response</a> (here's an excerpt):</p>
<blockquote><p>In general, running well-designed code on well-designed high-performance execution engines will yield about the same performance, independent of whether the language is static or dynamic, procedural, object-oriented or functional, imperative or declarative, lazy or strict, pure or impure.</p>
<p>In fact, I would propose that the performance of a system is solely dependent on the amount of money that was spent making it fast, and completely independent of any particular typing discipline, programming paradigm or language.</p></blockquote>
<p>The second question "What’s the difference between Duby and Juby and why would I need either of them?" has several parts:</p>
<ul>
<li>"What's invokedynamic and why does Duby "need a playmate"?"</li>
<li>"Could someone elaborate a little bit more on what this distinction is about?"</li>
<li>Why do we need (need!) another Ruby-related language? Or, rather, two more Ruby-related languages?</li>
</ul>
<p style="padding-left: 30px;">and another great <a href="http://stackoverflow.com/questions/1337137/whats-the-difference-between-duby-and-juby-and-why-would-i-need-either-of-them/1351895#1351895">answer</a> from Jorg (2 snippets):</p>
<p style="padding-left: 30px;"><em>2. Could someone elaborate a little bit more on what this distinction is about?</em></p>
<blockquote><p><a rel="nofollow" href="http://Duby.Kenai.Com/">Duby</a> is statically typed, <a rel="nofollow" href="https://GitHub.Com/Headius/Surinx/">Surinx</a> (which is the final name for what was for a short amount of time called <a rel="nofollow" href="https://GitHub.Com/Headius/Surinx/">Juby</a>) is dynamically typed. That's already all there is to it.</p>
<p>Actually, there is one small detail as a consequence of this: <a rel="nofollow" href="https://GitHub.Com/Headius/Surinx/">Surinx</a> syntax is a strict subset of <a rel="nofollow" href="http://Ruby-Lang.Org/">Ruby</a> syntax, i.e. every syntactically valid <a rel="nofollow" href="https://GitHub.Com/Headius/Surinx/">Surinx</a> program is also a syntactically valid <a rel="nofollow" href="http://Ruby-Lang.Org/">Ruby</a> program. <a rel="nofollow" href="http://Duby.Kenai.Com/">Duby</a> OTOH is <em>almost</em> a syntactic subset, except for its mandatory method parameter type annotations:</p>
<p>def foo(bar =&gt; Integer, baz =&gt; String) =&gt; Array<br />
# ...<br />
end<br />
<em>3. Why do we need (need!) another Ruby-related language?</em></p>
<p>Now, the funny thing is, <a rel="nofollow" href="http://Blog.Headius.Com/">Charlie</a> came to <a rel="nofollow" href="http://Ruby-Lang.Org/">Ruby</a>, because he didn't like his day job, doing Java development. And now, he <em>still</em> writes Java code all day long! Of course, he doesn't like that, and so he was looking for another programming language in which to implement the core of <a rel="nofollow" href="http://JRuby.Org/">JRuby</a>. One option would certainly be to just write it all in <a rel="nofollow" href="http://Ruby-Lang.Org/">Ruby</a>, but with <a rel="nofollow" href="http://C2.Com/cgi/wiki/?MetaCircularEvaluator">metacircular implementations</a> there usually comes a point of diminishing returns, where the implementations degenerates into academic masturbation. It would certainly make sense to rewrite the libraries, the ahead-of-time compiler (actually, <a rel="nofollow" href="https://GitHub.Com/JRuby/JRuby/blob/master/tool/compiler2.rb">that's already being done</a>) and some of the core classes in <a rel="nofollow" href="http://Ruby-Lang.Org/">Ruby</a>, but some parts of the engine core are better written in something closer to the execution model of the JVM itself.</p>
<p><a rel="nofollow" href="http://Blog.Headius.Com/">Charlie</a> was looking at the available options: <a rel="nofollow" href="http://Scala-Lang.Org/">Scala</a>, <a rel="nofollow" href="http://Groovy.CodeHaus.Org/">Groovy</a>, <a rel="nofollow" href="http://FanDev.Org/">Fan</a>, <a rel="nofollow" href="http://Clojure.Org/">Clojure</a>, <a rel="nofollow" href="http://Nice.SourceForge.Net/">Nice</a>, but all of them had a significant disadvantage: a fairly large language runtime. The size of the <a rel="nofollow" href="http://JRuby.Org/">JRuby</a> runtime is already a big problem in terms of memory consumption and startup latency (especially compared to <a rel="nofollow" href="https://GitHub.Com/RubySpec/MatzRuby/tree/ruby%5F1%5F8/">MRI</a> or <a rel="nofollow" href="https://GitHub.Com/RubySpec/MatzRuby/tree/trunk/">YARV</a> and even more so if you actually include the JVM itself in your measurements), and rewriting it in a language that adds its <em>own</em> runtime to that weight is simply a no-go. Unfortunately, there was no programming language which satisfied the two basic criteria <a rel="nofollow" href="http://Blog.Headius.Com/">Charlie</a> was looking for: no runtime and compiles to JVM bytecode that is at least as efficient as the equivalent Java.</p>
<p>So, he decided to create his own. The reason why he chose to use a syntax similar to <a rel="nofollow" href="http://Ruby-Lang.Org/">Ruby</a>, is actually quite simple: he didn't need to write a parser for it, <a rel="nofollow" href="http://Duby.Kenai.Com/">Duby</a> just uses <a rel="nofollow" href="http://JRuby.Org/">JRuby</a>'s already existing parser with one minor modification to support method parameter type annotations. (Actually, he also likes <a rel="nofollow" href="http://Ruby-Lang.Org/">Ruby</a>'s syntax, that was of course also a factor.)</p></blockquote>
<h2>Where are Programming Languages Going?</h2>
<p>What I took away from my morning readings is that <a href="http://victusfate.github.io/victusspiritus/uncategorized/2010/04/01/unorthodox-optimization/">unorthodox optimization</a> is already happening. People are selecting languages where they can quickly express themselves, and comprehend structures and flow easily. They're even going so far as to adapt these "syntactically pleasing" languages and highly dynamic forms to faster compilers (<a href="http://en.wikipedia.org/wiki/Just-in-time_compilation">Just in time compiling</a> on the <a href="http://en.wikipedia.org/wiki/Java_Virtual_Machine">Java Virtual Machine</a>, or even gcc)</p>
<p>The most popular and useful programming languages of the next ten years will share some of the following characteristics:</p>
<ul>
<li>Super Simple, Lightweight, &amp; Easy to Get Started: the lighter the syntax and language, the more inviting it is to new programmers. New programmers come from all backgrounds and specialties. They bring their practical domain expertise to bear on problems dedicated hackers have a hard time understanding</li>
<li>They will be net native. The most useful languages will be useful anywhere and everywhere on the web within browsers, JVMs, Javascript Optimizers, etc.</li>
<li>Super Fast: programmers are nearly always subject to premature optimization. I do it unconsciously, and it's a terrible habit. Of course there are mistakes aka "you're doing it wrong" (usually made when underlying structures aren't understood). <strong>If you're trying to solve a problem, make the solution your first priority, then iterate on speedups after you have true representation of the data flow and usage.</strong></li>
</ul>
<div class="zemanta-pixie" style="margin-top: 10px; height: 15px;"><a class="zemanta-pixie-a" title="Reblog this post [with Zemanta]" href="http://reblog.zemanta.com/zemified/6e66582b-bb0d-479b-94e7-253cbfefa85c/"><img class="zemanta-pixie-img" style="border: none; float: right;" src="http://img.zemanta.com/reblog_e.png?x-id=6e66582b-bb0d-479b-94e7-253cbfefa85c" alt="Reblog this post [with Zemanta]" /></a><span class="zem-script more-related pretty-attribution"><script src="http://static.zemanta.com/readside/loader.js" type="text/javascript"></script></span></div>
